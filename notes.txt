We start with our Mikado goal of replacing the use of the concrete class FileDB with the use of a database interface.  We'll create a feature flag to represent this goal:

 #include "applicationexception.hpp"
 #include "filedb.hpp"
 
+#define REPLACE_FILEDB_WITH_DATABASE_INTERFACE 0
+

And we'll just naively replace the FileDB with a Database reference.

  class UI {
    .
    .
    .

   private:
     Frame frame;
+#if !REPLACE_FILEDB_WITH_DATABASE_INTERFACE
     FileDB database;
+#else
+    Database &database;
+#endif
 

One of the first things that is clear is that this isn't going to work without
the database being a reference or a pointer. The simplest thing to do is
to make it be a reference, so we'll make that be a sub-goal.

 #include "filedb.hpp"
 
 #define REPLACE_FILEDB_WITH_DATABASE_INTERFACE 0
+#define CHANGE_DATABASE_TO_REFERENCE 0
 
 .
 .
 .

 class UI {
    .
    .
    .

   private:
     Frame frame;
 #if !REPLACE_FILEDB_WITH_DATABASE_INTERFACE
+#if !CHANGE_DATABASE_TO_REFERENCE
     FileDB database;
+#else
+    FileDB &database;
+#endif
 #else
     Database &database;
 #endif

This leads to a cascade of small changes.  First, we have to
initialize the reference, and to initialize the reference we have to have
something to initialize it with, so we need to have a parameter to the
UI constructor, which means we'll need to pass something to the constructor,
which means we'll need the FileDB to exist in the App.  Since we're following
the Mikado process strictly for this example, we'll make flags for each of
those steps.

 
 #define REPLACE_FILEDB_WITH_DATABASE_INTERFACE 0
 #define CHANGE_DATABASE_TO_REFERENCE 0
+#define INITIALIZE_REFERENCE 0
+#define ADD_DATABASE_PARAMETER 0
+#define PASS_DATABASE_TO_UI 0
+#define CREATE_DATABASE_IN_APP 1
 
 .
 .
 .
 
 class UI {
   public:
+#if !ADD_DATABASE_PARAMETER
     UI();
+#else
+    UI(FileDB &);
+#endif

     .
     .
     .
 };

 .
 .
 .

 class App {
   public:
+#if PASS_DATABASE_TO_UI
+    App()
+    : ui(database)
+    {
+    }
+#endif

    .
    .
    .

   private:
+#if CREATE_DATABASE_IN_APP
+    FileDB database;
+#endif
     UI ui;
     static inline string store_path;
 };

 .
 .
 .

+#if !ADD_DATABASE_PARAMETER
 UI::UI()
+#else
+UI::UI(FileDB &database)
+#endif
+#if INITIALIZE_REFERENCE
+: database(database)
+#endif
 {
   database.setStore(App::getStorageFile());
 }

We can enable CREATE_DATABASE_IN_APP without introducting any compilation
errors and without breaking anything. So we go ahead and bake in the
CREATE_DATABASE_IN_APP flag.

 #define INITIALIZE_REFERENCE 0
 #define ADD_DATABASE_PARAMETER 0
 #define PASS_DATABASE_TO_UI 0
-#define CREATE_DATABASE_IN_APP 1
 
 .
 .
 .

 class App {
   .
   .
   .
 
   private:
-#if CREATE_DATABASE_IN_APP
     FileDB database;
-#endif
     UI ui;
     static inline string store_path;
 };

Going up the list of flags, we find that enabling ADD_DATABASE_PARAMETER,
CREATE_DATABASE_IN_APP, INITIALIZE_REFERENCE, and
CHANGE_DATABASE_TO_REFERENCE work as well:

 #include "filedb.hpp"
 
 #define REPLACE_FILEDB_WITH_DATABASE_INTERFACE 0
-#define CHANGE_DATABASE_TO_REFERENCE 1
-#define INITIALIZE_REFERENCE 1
-#define ADD_DATABASE_PARAMETER 1
-#define PASS_DATABASE_TO_UI 1
 
 .
 .
 .

 class UI {
   public:
-#if !ADD_DATABASE_PARAMETER
-    UI();
-#else
     UI(FileDB &);
-#endif

   .
   .
   .

   private:
     Frame frame;
 #if !REPLACE_FILEDB_WITH_DATABASE_INTERFACE
-#if !CHANGE_DATABASE_TO_REFERENCE
-    FileDB database;
-#else
     FileDB &database;
-#endif
 #else
     Database &database;
 #endif

 };
 
 .
 .
 .
 
 class App {
   public:
-#if PASS_DATABASE_TO_UI
     App()
     : ui(database)
     {
     }
-#endif

   .
   .
   .
 };
 
 .
 .
 .
 
-#if !ADD_DATABASE_PARAMETER
-UI::UI()
-#else
 UI::UI(FileDB &database)
-#endif
-#if INITIALIZE_REFERENCE
 : database(database)
-#endif


If we try to enable the one remaining flag,
REPLACE_FILEDB_WITH_DATABASE_INTERFACE, we now see that the main issue is that
we don't have a Database interface class at all.  So we'll create that:
 
 
+struct Database {
+};


If we enable REPLACE_FILEDB_WITH_DATABASE_INTERFACE, we see that the next
issue is that we don't have a load() method, so we'll add that:

 struct Database {
+  virtual vector<string> load(const string &name) = 0;
 };
 
 

Now, if we enable REPLACE_FILEDB_WITH_DATABASE_INTERFACE, the main issue
is that our FileDB doesn't derive from Database.  We could think about
making FileDB derive from Database, but since FileDB is an external dependency,
we're going to need to do something else.  The simplest solution is to use an
adapter:

 #include "filedb.hpp"
 
 #define REPLACE_FILEDB_WITH_DATABASE_INTERFACE 0
+#define CHANGE_PARAMETER_TO_ADAPTER 0
 
 .
 .
 .
 
 class UI {
   public:
+#if !CHANGE_PARAMETER_TO_ADAPTER
     UI(FileDB &);
+#else
+    UI(FileDBAdapter &);
+#endif
   .
   .
   .
 };

 .
 .
 .
 
+#if !CHANGE_PARAMETER_TO_ADAPTER
 UI::UI(FileDB &database)
+#else
+UI::UI(FileDBAdapter &database)
+#endif
 : database(database)
 {
   database.setStore(App::getStorageFile());
 }


And to make that compile, we'll need to create the adapter:
 
 
+struct FileDBAdapter {
+};


 class UI {
   .
   .
   .
 };

If we try to enable CHANGE_PARAMETER_TO_ADAPTER, we see that we're not
actually passing an adapter for the database parameter.
 
 #define REPLACE_FILEDB_WITH_DATABASE_INTERFACE 0
 #define CHANGE_PARAMETER_TO_ADAPTER 0
+#define PASS_ADAPTER 0
 
 .
 .
 .

 class App {
   public:
     App()
+#if !PASS_ADAPTER
     : ui(database)
+#else
+    : ui(database_adapter)
+#endif
     {
     }
 
  .
  .
  .

   private:
     FileDB database;
+#if PASS_ADAPTER
+    FileDBAdapter database_adapter;
+#endif
     UI ui;
     static inline string store_path;
 };


To make PASS_ADAPTER work, we need to make the FileDBAdapter actually derive
from the Database interface.
 
 
-struct FileDBAdapter {
-};
+struct FileDBAdapter : Database {
+};
 
 
If we try to enable PASS_ADAPTER, we find that we can't because we haven't
actually implemented the load() method:

 #define REPLACE_FILEDB_WITH_DATABASE_INTERFACE 0
 #define CHANGE_PARAMETER_TO_ADAPTER 0
 #define PASS_ADAPTER 0
+#define ADD_LOAD_METHOD_TO_ADAPTER 0
 
 .
 .
 .
 
 struct FileDBAdapter : Database {
+#if ADD_LOAD_METHOD_TO_ADAPTER
+  vector<string> load(const string &name) override
+  {
+    return file_db.load(name);
+  }
+#endif
 };
 
 
If we try to enable ADD_LOAD_METHOD_TO_ADAPTER, we see that we can't because
we don't have access to the FileDB from the adapter, so we can add that
as a parameter to the constructor and pass in the parameter when we create
the App::database_adapter member:
 
 
 struct FileDBAdapter : Database {
+  FileDB &file_db;
+
   .
   .
   .
 };

 .
 .
 .

 class App {
   .
   .
   .

   private:
     FileDB database;
 #if PASS_ADAPTER
+    FileDBAdapter database_adapter{database};
 #endif
     UI ui;
     static inline string store_path;
 };

Enabling ADD_LOAD_METHOD_TO_ADAPTER now works, so we can bake it in:

 #define REPLACE_FILEDB_WITH_DATABASE_INTERFACE 0
 #define CHANGE_PARAMETER_TO_ADAPTER 0
 #define PASS_ADAPTER 0
-#define ADD_LOAD_METHOD_TO_ADAPTER 1
 
 .
 .
 .

 struct FileDBAdapter : Database {
   FileDB &file_db;
 
-#if ADD_LOAD_METHOD_TO_ADAPTER
   vector<string> load(const string &name) override
   {
     return file_db.load(name);
   }
-#endif
 };
 
 
The compiler warns about a missing constructor in FileDBAdapter, so
we'll go ahead and add that:

 #define REPLACE_FILEDB_WITH_DATABASE_INTERFACE 0
 #define CHANGE_PARAMETER_TO_ADAPTER 0
 #define PASS_ADAPTER 0
 
 .
 .
 .

 struct FileDBAdapter : Database {
   FileDB &file_db;
 
+  FileDBAdapter(FileDB &file_db)
+  : file_db(file_db)
+  {
+  }
+

If we try to enable PASS_ADAPTER, we see that we can't because it doesn't have
a setStore() method.  We might be tempted to add this to our FileDBAdapter
class, but that doesn't seem to match the role of an adapter.  Instead, we can
move this functionality to App, which still knows the database is a FileDB:

 
 class App {
   public:
     App()
 #if !PASS_ADAPTER
     : ui(database)
 #else
     : ui(database_adapter)
 #endif
     {
+      database.setStore(App::getStorageFile());
     }

     .
     .
     .
  };
 
 .
 .
 .

 #if !PASS_ADAPTER
 UI::UI(FileDB &database)
 #else
 UI::UI(FileDBAdapter &database)
 #endif
 : database(database)
 {
-  database.setStore(App::getStorageFile());
 }
 
 

We now find that all the remaining flags can be enabled without causing
any issues, so we bake all of this in:

 #include "applicationexception.hpp"
 #include "filedb.hpp"
 
-#define REPLACE_FILEDB_WITH_DATABASE_INTERFACE 1
-#define CHANGE_PARAMETER_TO_ADAPTER 1
-#define PASS_ADAPTER 1
-
 .
 .
 .
 
 class UI {
   public:
-#if !CHANGE_PARAMETER_TO_ADAPTER
-    UI(FileDB &);
-#else
     UI(FileDBAdapter &);
-#endif
 
    .
    .
    .
 
   private:
     Frame frame;
-#if !REPLACE_FILEDB_WITH_DATABASE_INTERFACE
-    FileDB &database;
-#else
     Database &database;
-#endif
 
 .
 .
 .

 class App {
   public:
     App()
-#if !PASS_ADAPTER
-    : ui(database)
-#else
     : ui(database_adapter)
-#endif
     {
       database.setStore(App::getStorageFile());
     }
   .
   .
   .
 
   private:
     FileDB database;
-#if PASS_ADAPTER
     FileDBAdapter database_adapter{database};
-#endif
     UI ui;
     static inline string store_path;
 };

 .
 .
 .
 
-#if !CHANGE_PARAMETER_TO_ADAPTER
-UI::UI(FileDB &database)
-#else
 UI::UI(FileDBAdapter &database)
-#endif
 : database(database)
 {
 }


At this point, there are no more flags, but there's some easy additional
refactoring we can do.  The first is to generalize the UI constructor to take a
Database instead of a FileDBAdapter.

 class UI {
   public:
-    UI(FileDBAdapter &);
+    UI(Database &);
 
     .
     .
     .
 };

 .
 .
 .
 
-UI::UI(FileDBAdapter &database)
+UI::UI(Database &database)
 : database(database)
 {
 }


We can also see that we can use the adapter to move the FileDB up another level
into the Launcher:
 
 class App {
   public:
-    App()
-    : ui(database_adapter)
+    App(FileDB &database)
+    : database_adapter(database),
+      ui(database_adapter)
     {
-      database.setStore(App::getStorageFile());
     }

     .
     .
     .

   private:
-    FileDB database;
-    FileDBAdapter database_adapter{database};
+    FileDBAdapter database_adapter;
     UI ui;
     static inline string store_path;
 };

 .
 .
 .

 class Launcher {
   public:
     static void main(const vector<string> &argv)
     {
       try {
         App::setStorageFile(argv[0]);
-        App app;
+        FileDB database;
+        database.setStore(App::getStorageFile());
+        App app{database};
         app.launch();
       }
       .
       .
       .
     }
 };


This allows us to move the FileDBAdapter up to the Launcher as well:
 
 class App {
   public:
-    App(FileDB &database)
-    : database_adapter(database),
-      ui(database_adapter)
+    App(FileDBAdapter &database_adapter)
+    : ui(database_adapter)
     {
     }
 
   .
   .
   .
 
   private:
-    FileDBAdapter database_adapter;
     UI ui;
     static inline string store_path;
 };

 .
 .
 .

 class Launcher {
   public:
     static void main(const vector<string> &argv)
     {
       try {
         App::setStorageFile(argv[0]);
         FileDB database;
         database.setStore(App::getStorageFile());
-        App app{database};
+        FileDBAdapter database_adapter(database);
+        App app{database_adapter};
         app.launch();

And we generalize the App constructor:
 
 class App {
   public:
-    App(FileDBAdapter &database_adapter)
-    : ui(database_adapter)
+    App(Database &database)
+    : ui(database)
     {
     }
 

The calls to setStorageFile and getStorageFile are closely related, so let's
move them together:
     static void main(const vector<string> &argv)
     {
       try {
-        App::setStorageFile(argv[0]);
         FileDB database;
+        App::setStorageFile(argv[0]);
         database.setStore(App::getStorageFile());
         FileDBAdapter database_adapter(database);
         App app{database_adapter};

And then it is clear we don't need to use getStorageFile() at all:

     static void main(const vector<string> &argv)
     {
       try {
         FileDB database;
         App::setStorageFile(argv[0]);
-        database.setStore(App::getStorageFile());
+        database.setStore(argv[0]);
         FileDBAdapter database_adapter(database);
         App app{database_adapter};
         app.launch();

There are no remaining calls to App::getStorageFile(), which means
App::store_path is no longer needed, which means setStorageFile no longer does
anything, and we can remove all of this:

 class App {
   public:
     .
     .
     .

-    static const string& getStorageFile()
-    {
-      return store_path;
-    }
-
-    static void setStorageFile(const string &store_path)
-    {
-      App::store_path = store_path;
-    }
-
   private:
     UI ui;
-    static inline string store_path;
 };
 
 .
 .
 .

 class Launcher {
   public:
     static void main(const vector<string> &argv)
     {
       try {
         FileDB database;
-        App::setStorageFile(argv[0]);
         database.setStore(argv[0]);
         FileDBAdapter database_adapter(database);
         App app{database_adapter};

At this point, we can say that we've achieved our initial goal of
abstracting the database.
